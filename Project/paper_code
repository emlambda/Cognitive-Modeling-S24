import pandas as pd
import numpy as np
import stan
from datetime import datetime

import arviz as az

import matplotlib.pyplot as plt
import seaborn as sns

import nest_asyncio
nest_asyncio.apply()

def get_season(month):
    if month in ["03", "04", "05"]:  # Spring: March, April, May
        return 1
    elif month in ["06", "07", "08"]:  # Summer: June, July, August
        return 2
    elif month in ["09", "10", "11"]:  # Fall: September, October, November
        return 3
    else:  # Winter: December, January, February
        return 0

def calculate_mothers_day(year):
    first_sunday = pd.Timestamp(f'{year}-05-01').to_pydatetime()
    while first_sunday.weekday() != 6:  # 6 corresponds to Sunday
        first_sunday += pd.Timedelta(days=1)
    
    # Add 7 days to get to the second Sunday
    second_sunday = first_sunday + pd.Timedelta(days=7)
    
    return second_sunday.strftime("%m/%d/%y")

if __name__ == '__main__':
    
    df = pd.read_csv('BPD_Part_1_Victim_Based_Crime_Data.csv')
    
    df = df[(df.Description == 'SHOOTING')+((df.Description == 'HOMICIDE')*(df.Weapon == 'FIREARM'))] # only looking at gun violence rows
    
    df = df.groupby('CrimeDate').size().reset_index(name='shootings')
    df['CrimeDate'] = pd.to_datetime(df.CrimeDate).dt.strftime("%m/%d/%y")
    
    full_date_range = pd.date_range(start=df['CrimeDate'].min(), end=df['CrimeDate'].max(), freq='D').strftime("%m/%d/%y")
    
    df = pd.merge(pd.DataFrame({'CrimeDate': full_date_range}), df, on='CrimeDate',how='left')
    df = df.fillna(0)
    
    ceasefire_fridays = [
    "08/04/2017",
    "11/03/2017",
    "02/02/2018",
    "05/11/2018",
    "08/03/2018",
    "11/02/2018",
    "02/01/2019",
    "05/10/2019",
    "08/02/2019"
    ]

    ceasefire_fridays = [datetime.strptime(date_str, "%m/%d/%Y") for date_str in ceasefire_fridays]

    # Generate the ceasefire weekends
    ceasefire_weekends = [pd.date_range(start=friday, periods=3, freq='D') for friday in ceasefire_fridays]
    ceasefire_weekends = [date.strftime("%m/%d/%y") for sublist in ceasefire_weekends for date in sublist]
    
    df['ceasefire'] = df['CrimeDate'].isin(ceasefire_weekends)
    
    #df.ceasefire[df.CrimeDate.isin(ceasefire_weekends)] = 1
    
    mothers_days = []
    for year in pd.to_datetime(df['CrimeDate']).dt.year.unique():
        mothers_days.append(calculate_mothers_day(year))

    df['mothersday'] = df['CrimeDate'].isin(mothers_days)
    
    # adding relevant date information, also encoding all
    
    df.loc[:,'weekday'] = pd.to_datetime(df.CrimeDate).dt.day_name().astype('category').cat.codes
    df.loc[:,'yearday'] = pd.to_datetime(df.CrimeDate).dt.dayofyear
    df.loc[:,'season'] = [get_season(c.split("/")[0]) for c in df.CrimeDate]
    df.loc[:,'jul'] = pd.to_datetime(df.CrimeDate).apply(lambda x: x.toordinal())
    
    '''
    * Overall time trend
        + We use a spline to estimate the overall time trend, which allows for "curvy" relationships while avoiding overfitting
        
    * Yearly seasonality
        + We account for yearly seasonality using a spline with a cyclical constraint to ensure that the seasonal effect begins where it ended
        
    * Day of the week
        + We allow intercepts to vary for days of the week in case weekends have different patterns of shootings than weekdays
        
    * Calendar day
        + We allow varying intercepts for each day of the year in case "special days", like Christmas, show different patterns of shootings 
        
    * Mother's Day
        + We use a binary indicator for Mother's Day, which is the second Sunday in May and always coincides with ceasefire
        
    * Ceasefire effect
        + We use a binary indicator for days occurring during ceasefire weekends to estimate the impact of ceasefire after accounting for all of the above
    '''
    N = len(df)
    
    data = {
        'n': N,
        'y': df['shootings'].values.astype(int),
        'ceasefire': df['ceasefire'].values.astype(int)+1,
        'mothersday': df['mothersday'].values.astype(int)+1,
        'yday': df['yearday'].values.astype(int),
        'weekday': df['weekday'].values.astype(int)+1,
        'season': df['season'].values.astype(int)+1
    }

    stan_code = """
    data {
        int<lower=1> n;                   // Number of observations
        array[n] int y;                   // Number of shootings per day
        array[n] int ceasefire;
        array[n] int mothersday;
        array[n] int yday;
        array[n] int weekday;
        array[n] int season;
    }

    parameters {
        vector[n] mu_innovations;
        
        vector[366] yearly_effects;
        vector[7] weekday_effects;
        vector[2] ceasefire_effects;
        vector[2] mothersday_effects;
        real<lower=0> sigma_mu;
        real<lower=0> sigma_yday;
        real<lower=0> sigma_weekday;
        real<lower=0> sigma_binary;
        real baseline;
        //vector[2] ceasefire_effects;
        }

    transformed parameters {
        // Zero-mean seasonal term
        vector[366] y_year;
        vector[7] y_week;
        vector[2] y_cease;
        vector[2] y_mother;
        vector[n] mu;
        //vector[n] ceasefire_term;

        {
            vector[366] year_with_trend;
            real trend;
            year_with_trend = cumulative_sum(yearly_effects);
            trend = year_with_trend[366];
            for (i in 1:366)
                y_year[i] = sigma_yday/100 * (year_with_trend[i] - trend * i/366.0);
        }
        {
            vector[7] week_with_trend;
            real trend;
            week_with_trend = cumulative_sum(weekday_effects);
            trend = week_with_trend[7];
            for (i in 1:7)
                y_week[i] = sigma_weekday/100 * (week_with_trend[i] - trend * i/7.0);
        }
        {
            vector[2] cease_with_trend;
            vector[2] mother_with_trend;
            real cease_trend;
            real mother_trend;
            cease_with_trend = cumulative_sum(ceasefire_effects);
            mother_with_trend = cumulative_sum(mothersday_effects);
            cease_trend = cease_with_trend[2];
            mother_trend = mother_with_trend[2];
            for (i in 1:2) {
                y_cease[i] = sigma_binary/100 * (cease_with_trend[i] - cease_trend * i/2);
                y_mother[i] = sigma_binary/100 * (mother_with_trend[i] - mother_trend * i/2);
            }
        }
        mu = sigma_mu/100 * cumulative_sum(mu_innovations);
        
        // Compute the weekday effects for each observation
    }

    model {
        yearly_effects ~ normal(0, 1);
        mu_innovations ~ normal(0, 1);
        y ~ poisson_log(baseline + mu + y_year[yday] + y_week[weekday] + y_cease[ceasefire] + y_mother[mothersday]);
        sigma_mu ~ lognormal(-3.5 + log(100), 2);
        sigma_yday ~ lognormal(-3.5 + log(100), 2);
    }

    generated quantities {
        vector[n] lin_pred;    // Linear predictor

        // Compute the linear predictor for each observation
        for (i in 1:n) {
            lin_pred[i] = baseline + mu[i] + y_year[yday[i]] + y_week[weekday[i]] + y_cease[ceasefire[i]] + y_mother[mothersday[i]];
        }
    }

    """

    # Compile the Stan model
    model = stan.build(stan_code, data=data)
    
    fit = model.sample(num_chains=4, num_samples=500, num_warmup=500)

    import matplotlib.dates as mdates
    # Plotting
    plt.figure(figsize=(10, 6))
    plt.scatter(df['CrimeDate'], df['shootings'], alpha=0.2, label='Observations')
    plt.plot(df['CrimeDate'], np.mean(fit['lin_pred'], axis=1), color='red', alpha=0.5, label='Model Prediction')
    plt.xlabel('Date')
    plt.ylabel('Daily Shootings')
    plt.title('Model vs Observations')
    plt.legend()
    plt.gca().xaxis.set_major_locator(mdates.YearLocator(month=12))
    #plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%Y'))
    plt.show()
